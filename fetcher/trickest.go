package fetcher

import (
	"bufio"
	"bytes"
	"crypto/md5"
	"fmt"
	"io"
	"io/ioutil"
	"net/url"
	"path/filepath"
	"strings"
	"time"

	"github.com/PuerkitoBio/goquery"
	"github.com/inconshreveable/log15"
	"github.com/russross/blackfriday/v2"
	"golang.org/x/xerrors"

	"github.com/vulsio/go-exploitdb/git"
	"github.com/vulsio/go-exploitdb/models"
	"github.com/vulsio/go-exploitdb/util"
)

const trickestURL string = "https://github.com/trickest/cve.git"

type trickestCVE struct {
	CVEID           string
	Description     string
	Products        []string
	Versions        []string
	Vulnerabilities []string
	PoCs            []string
}

// FetchTrickest :
func FetchTrickest() ([]models.Exploit, error) {
	dir := filepath.Join(util.CacheDir(), "trickest")
	updatedFiles, err := git.CloneOrPull(trickestURL, dir)
	if err != nil {
		return nil, xerrors.Errorf("Failed to clone or pull trickest/cve repository. err: %w", err)
	}

	var targets []map[string]struct{}
	targetFiles := 0
	for year := 1999; year <= time.Now().Year(); year++ {
		target, err := util.FilterTargets(fmt.Sprint(year), updatedFiles)
		if err != nil {
			return nil, xerrors.Errorf("Failed to filter target files: %w", err)
		}

		if len(target) != 0 {
			targets = append(targets, target)
			targetFiles += len(target)
		}
	}
	if targetFiles == 0 {
		log15.Debug("Trickest CVE: no updated file")
		return nil, nil
	}
	log15.Debug(fmt.Sprintf("Trickest CVE: updated files: %d", targetFiles))

	entries := []trickestCVE{}
	for _, target := range targets {
		if err = util.FileWalk(dir, target, func(r io.Reader, path string) error {
			content, err := ioutil.ReadAll(r)
			if err != nil {
				return xerrors.Errorf("Failed to Read file. path: %s, err: %w", path, err)
			}

			trickest, err := readTrickestHTML(splitTrickestMD(content))
			if err != nil {
				return xerrors.Errorf("Failed to read Trickest HTML. err: %w", err)
			}

			entries = append(entries, trickest)
			return nil
		}); err != nil {
			return nil, xerrors.Errorf("Failed to walk Trickest CVE. err: %w", err)
		}
	}

	exploits := []models.Exploit{}
	for _, e := range entries {
		products := []models.TrickestProduct{}
		for _, product := range e.Products {
			products = append(products, models.TrickestProduct{Product: product})
		}
		versions := []models.TrickestVersion{}
		for _, version := range e.Versions {
			versions = append(versions, models.TrickestVersion{Version: version})
		}
		vulnerabilities := []models.TrickestVulnerability{}
		for _, vulnerability := range e.Vulnerabilities {
			vulnerabilities = append(vulnerabilities, models.TrickestVulnerability{Vulnerability: vulnerability})
		}

		for _, poc := range e.PoCs {
			exploits = append(exploits, models.Exploit{
				ExploitType:     models.TrickestType,
				ExploitUniqueID: fmt.Sprintf("%s-%x", models.TrickestType, md5.Sum([]byte(fmt.Sprintf("%s-%s", e.CVEID, poc)))),
				URL:             poc,
				Description:     e.Description,
				CveID:           e.CVEID,
				Trickest: &models.Trickest{
					Products:        append([]models.TrickestProduct{}, products...),
					Versions:        append([]models.TrickestVersion{}, versions...),
					Vulnerabilities: append([]models.TrickestVulnerability{}, vulnerabilities...),
				},
			})
		}
	}
	return exploits, nil
}

func splitTrickestMD(content []byte) (string, string, string) {
	cveHTML := []string{}
	descHTML := []string{}
	pocHTML := []string{}
	mode := "cve"
	s := bufio.NewScanner(bytes.NewReader(blackfriday.Run(content)))
	for s.Scan() {
		t := s.Text()
		if strings.HasPrefix(t, "<h3>Description</h3>") {
			mode = "desc"
		}
		if strings.HasPrefix(t, "<h3>POC</h3>") {
			mode = "poc"
		}
		switch mode {
		case "cve":
			cveHTML = append(cveHTML, t)
		case "desc":
			descHTML = append(descHTML, t)
		case "poc":
			pocHTML = append(pocHTML, t)
		}
	}

	return strings.Join(cveHTML, ""), strings.Join(descHTML, ""), strings.Join(pocHTML, "")
}

func readTrickestHTML(cveHTML, descHTML, pocHTML string) (trickestCVE, error) {
	var trickest trickestCVE
	cveDoc, err := goquery.NewDocumentFromReader(strings.NewReader(cveHTML))
	if err != nil {
		return trickestCVE{}, xerrors.Errorf("Failed to read CVE content. err: %w", err)
	}
	trickest.CVEID = cveDoc.Find("h3").Text()
	cveDoc.Find("img").Each(func(_ int, s *goquery.Selection) {
		src := s.AttrOr("src", "")
		if src == "" {
			return
		}
		u, err := url.Parse(src)
		if err != nil {
			log15.Debug(fmt.Sprintf("Trickest CVE: failed to parse img src: %s", err))
			return
		}
		l := u.Query().Get("label")
		m := u.Query().Get("message")
		if l == "" || m == "" {
			return
		}

		switch l {
		case "Product":
			trickest.Products = append(trickest.Products, m)
		case "Version":
			trickest.Versions = append(trickest.Versions, m)
		case "Vulnerability":
			trickest.Vulnerabilities = append(trickest.Vulnerabilities, m)
		default:
			log15.Debug(fmt.Sprintf("Trickest CVE: new label: %s", l))
		}
	})

	descDoc, err := goquery.NewDocumentFromReader(strings.NewReader(descHTML))
	if err != nil {
		return trickestCVE{}, xerrors.Errorf("Failed to read Description content. err: %w", err)
	}
	trickest.Description = descDoc.Find("p").Text()

	pocDoc, err := goquery.NewDocumentFromReader(strings.NewReader(pocHTML))
	if err != nil {
		return trickestCVE{}, xerrors.Errorf("Failed to read PoCs content. err: %w", err)
	}
	pocDoc.Find("a").Each(func(_ int, s *goquery.Selection) {
		trickest.PoCs = append(trickest.PoCs, s.Text())
	})

	return trickest, nil
}
