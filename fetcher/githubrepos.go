package fetcher

import (
	"crypto/md5"
	"encoding/json"
	"fmt"
	"io"
	"io/ioutil"
	"path/filepath"
	"sort"
	"strings"
	"time"

	"github.com/inconshreveable/log15"
	"github.com/vulsio/go-exploitdb/git"
	"github.com/vulsio/go-exploitdb/models"
	"github.com/vulsio/go-exploitdb/util"
	"golang.org/x/xerrors"
)

const githubURL string = "https://github.com/nomi-sec/PoC-in-GitHub.git"

// FetchGitHubRepos :
func FetchGitHubRepos(stars, forks int) (exploits []models.Exploit, err error) {
	dir := filepath.Join(util.CacheDir(), "github")
	updatedFiles, err := git.CloneOrPull(githubURL, dir)
	if err != nil {
		return nil, xerrors.Errorf("Failed to clone or pull nomi-sec/PoC-in-GitHub repository. err: %w", err)
	}

	var targets []map[string]struct{}
	targetFiles := 0
	for year := 1999; year <= time.Now().Year(); year++ {
		target, err := util.FilterTargets(fmt.Sprint(year), updatedFiles)
		if err != nil {
			return nil, xerrors.Errorf("Failed to filter target files: %w", err)
		}

		if len(target) != 0 {
			targets = append(targets, target)
			targetFiles += len(target)
		}
	}
	if targetFiles == 0 {
		log15.Debug("PoC-in-GitHub: no updated file")
		return nil, nil
	}
	log15.Debug(fmt.Sprintf("PoC-in-GitHub: updated files: %d", targetFiles))

	entries := map[string][]models.GitHubRepoJSON{}
	for _, target := range targets {
		if err := util.FileWalk(dir, target, func(r io.Reader, path string) error {
			content, err := ioutil.ReadAll(r)
			if err != nil {
				return err
			}

			var pocs []models.GitHubRepoJSON
			if err = json.Unmarshal(content, &pocs); err != nil {
				return xerrors.Errorf("Failed to decode GitHubRepoJSON: %w", err)
			}

			dirPaths := strings.Split(path, "/")
			cveID := strings.Split(dirPaths[len(dirPaths)-1], ".")[0]
			entries[cveID] = pocs
			return nil
		}); err != nil {
			return nil, xerrors.Errorf("Failed to walk PoC-in-GitHub. err: %w", err)
		}
	}

	for cveID, pocs := range entries {
		for _, poc := range pocs {
			if poc.Star < stars || poc.Fork < forks {
				continue
			}

			githubRepoExploit := models.Exploit{
				ExploitUniqueID: fmt.Sprintf("%s-%x", models.GitHubRepositoryType, md5.Sum([]byte(cveID+poc.URL))),
				ExploitType:     models.GitHubRepositoryType,
				URL:             poc.URL,
				CveID:           cveID,
				Description:     poc.Description,
				GitHubRepository: &models.GitHubRepository{
					Star:      poc.Star,
					Fork:      poc.Fork,
					CreatedAt: poc.CreatedAt,
					UpdatedAt: poc.UpdatedAt,
				},
			}
			exploits = append(exploits, githubRepoExploit)
		}
	}

	sort.Slice(exploits, func(i, j int) bool {
		return (exploits[i].GitHubRepository.Star + exploits[i].GitHubRepository.Fork) > (exploits[j].GitHubRepository.Star + exploits[j].GitHubRepository.Fork)
	})

	return exploits, nil
}
